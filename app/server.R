shinyServer(function(input, output, session) {


### SMR Completeness --------------------------------------------------------

  ## Filters for HB, Month, Mandatory, Percentage Threshold
  main_filters_completeness <- reactive({ 
  smr_completeness %>%
  filter(case_when(input$hb_in %in% unique(smr_completeness$hb_name) ~ hb_name == input$hb_in,
                       TRUE ~ hb_name==hb_name),
         case_when(input$month_in %in% unique(smr_completeness$month_record_inserted) ~ 
                     hb_name == input$month_in,
                   TRUE ~ month_record_inserted==month_record_inserted),
        case_when(input$mandatory_in == "Mandatory data items" ~ mandatory == "mandatory",
                            input$mandatory_in == "Non-mandatory data items" ~ mandatory == "not mandatory",
                            TRUE ~ mandatory == mandatory),
        percent_complete_month >= input$percentage_in
        )
      })
  
  ## Filter for data item (the data item filter is nested and depends on the user's input in the Mandatory filter)
   
   #update Data Item selection list based on input$mandatory_in
  observeEvent(input$mandatory_in, {
    updateSelectInput(session, inputId = "data_item_in",
                      choices = c("(All)", unique(main_filters_completeness()$data_item)))
  })
    #implement filter
  data_item_completeness <- reactive({
    main_filters_completeness()%>%
    filter(case_when(input$data_item_in %in% unique(main_filters_completeness()$data_item) ~
                       data_item == input$data_item_in,
                     TRUE ~ data_item == data_item))
  })
  
  ## Render the final table
  output$completeness_table <- renderTable(data_item_completeness()%>%
                                             select(-na_count, -month_total, -mandatory) %>%
                                             arrange(percent_complete_month))
  

### SMR Audit ---------------------------------------------------------------


  #If user selects an audit, filter the data for selected audit, if they select (All) return unfiltered table 
  audit <- reactive({
    if(input$SMRaudit %in% smr_audit$audit){
      smr_audit %>%
        filter(audit==input$SMRaudit)
    }
    else {
      smr_audit
    }
  })
  
  #observe the audit selected by user and update the choices according to the audit selection
  observeEvent(input$SMRaudit, {
    updateSelectInput(session, inputId = "Year", choices = c(unique(audit()$year)))
  })
  
  
  #reactive year selection, returns data filtered by the year selected 
  year <- reactive({audit()%>%
      filter(year == input$Year)})
  
  # year <- reactive({
  #   if(input$Year %in% audit()$Year){
  #     audit() %>%
  #       filter(Year == input$Year)
  #   }
  #   else {
  #     audit()
  #   }
  # })
  
  
  #observe the year selected and update the health board choices, the (All) option is added so that users can view all HBs by default
  observeEvent(input$Year, {
    updateSelectInput(session, inputId = "Healthboard", choices = c("(All)", unique(year()$healthboard)))
  })
  
  #reactive health board selection, if a specific HB is selected filter the data further, else return the table reaturned by the reactive year()
  healthboard <- reactive({
    if(input$Healthboard %in% year()$healthboard){
      year()%>%
        filter(healthboard == input$Healthboard)
    }
    else {
      year()
    }
  })
  
  
  #update the data item choices according to the SMR selected
  observeEvent(input$SMRaudit, {
    updateSelectInput(session,"DataItemName", choices = c("(All)",unique(audit()$data_item_name)))
  })  
  
  
  #final output applies a data item filter if user picks a specific data item, else it returns table generated by the reactive healthboard()  
  output$audit_data <- renderTable({
    if(input$DataItemName %in% healthboard()$data_item_name){
      healthboard()%>%
        filter(data_item_name == input$DataItemName) %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Mean Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
    else {
      healthboard() %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
  })
  

  
###the following lines relate to SMR02 coding discrepancies
  output$error_1 <- DT::renderDataTable({
    DT::datatable(error_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15)) #default the displayed rows
  },
  filter = 'top',
  rownames = FALSE)    
  
  output$error_2 <- DT::renderDataTable({
    DT::datatable(error_2_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE) 
  
  
  output$error_3 <- DT::renderDataTable({
    DT::datatable(error_3_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  
  output$error_4 <- DT::renderDataTable({
    DT::datatable(error_4_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)  
  
  
  output$error_5 <- DT::renderDataTable({
    DT::datatable(error_5_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$error_6 <- DT::renderDataTable({
    DT::datatable(error_6_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$query <- DT::renderDataTable({
    DT::datatable(query_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_1 <- DT::renderDataTable({
    DT::datatable(split_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_2 <- DT::renderDataTable({
    DT::datatable(split_2_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_3 <- DT::renderDataTable({
    DT::datatable(split_3_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_4 <- DT::renderDataTable({
    DT::datatable(split_4_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_5 <- DT::renderDataTable({
    DT::datatable(split_5_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$error1map <- renderLeaflet({ #create maps
    error1map
  })
  
  output$error2map <- renderLeaflet({
    error2map
  })
  
  output$error3map <- renderLeaflet({
    error3map
  })
  
  output$error4map <- renderLeaflet({
    error4map
  })
  
  output$error5map <- renderLeaflet({
    error5map
  })
  
  output$error6map <- renderLeaflet({
    error6map
  })
  
  output$querymap <- renderLeaflet({
    query_map
  })
  
  
})
