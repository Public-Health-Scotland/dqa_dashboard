shinyServer(function(input, output, session) {

### SMR Completeness  
  hb_completeness <- reactive({
    if(input$hb_in %in% unique(smr_completeness$hb_name)){
      smr_completeness %>%
        filter(hb_name==input$hb_in)
    }
    else{
      smr_completeness
    }
  })
  
  month_completeness <- reactive({
    if(input$month_in %in% unique(hb_completeness()$month_record_inserted)){
      hb_completeness() %>%
        filter(month_record_inserted==input$month_in)
    }
    else{
      hb_completeness()
    }
  })
  
  data_item_completeness <- reactive({
    if(input$data_item_in %in% unique(month_completeness()$data_item)){
      month_completeness()%>%
        filter(data_item==input$data_item_in)
    }
    else{
      month_completeness()
    }
  })
  
  data_item_percent <- reactive({
    data_item_completeness()%>%
      filter(case_when(input$percentage_in == "0% - 20%" ~ percent_complete_month < 20,
                       input$percentage_in == "20% <" ~ percent_complete_month > 20,
                       input$percentage_in == "50% <" ~ percent_complete_month > 50,
                       input$percentage_in == "80% <" ~ percent_complete_month > 80,
                       input$percentage_in == "100%" ~ percent_complete_month == 100,
                       TRUE~percent_complete_month == percent_complete_month))
  })
  
  output$completeness_table <- renderTable(data_item_percent())
  

### SMR Audit
  #If user selects an audit, filter the data for selected audit, if they select (All) return unfiltered table 
  audit <- reactive({
    if(input$SMRaudit %in% smr_audit$audit){
      smr_audit %>%
        filter(audit==input$SMRaudit)
    }
    else {
      smr_audit
    }
  })
  
  #observe the audit selected by user and update the choices according to the audit selection
  observeEvent(input$SMRaudit, {
    updateSelectInput(session, inputId = "Year", choices = c(unique(audit()$year)))
  })
  
  
  #reactive year selection, returns data filtered by the year selected 
  year <- reactive({audit()%>%
      filter(year == input$Year)})
  
  # year <- reactive({
  #   if(input$Year %in% audit()$Year){
  #     audit() %>%
  #       filter(Year == input$Year)
  #   }
  #   else {
  #     audit()
  #   }
  # })
  
  
  #observe the year selected and update the health board choices, the (All) option is added so that users can view all HBs by default
  observeEvent(input$Year, {
    updateSelectInput(session, inputId = "Healthboard", choices = c("(All)", unique(year()$healthboard)))
  })
  
  #reactive health board selection, if a specific HB is selected filter the data further, else return the table reaturned by the reactive year()
  healthboard <- reactive({
    if(input$Healthboard %in% year()$healthboard){
      year()%>%
        filter(healthboard == input$Healthboard)
    }
    else {
      year()
    }
  })
  
  
  #update the data item choices according to the SMR selected
  observeEvent(input$SMRaudit, {
    updateSelectInput(session,"DataItemName", choices = c("(All)",unique(audit()$data_item_name)))
  })  
  
  
  #final output applies a data item filter if user picks a specific data item, else it returns table generated by the reactive healthboard()  
  output$audit_data <- renderTable({
    if(input$DataItemName %in% healthboard()$data_item_name){
      healthboard()%>%
        filter(data_item_name == input$DataItemName) %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Mean Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
    else {
      healthboard() %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
  })
  

  
###the following lines relate to SMR02 coding discrepancies

  output$error_1 <- renderTable({
    error_1_table %>%
      filter(year == input$year1)
  })
  
  output$error_2 <- renderTable({
    error_2_table %>%
      filter(year == input$year2)
  })
  
  
  output$error_3 <- renderTable({
    error_3_table %>%
      filter(year == input$year3)
  })
  
  
  output$error_4 <- renderTable({
    error_4_table %>%
      filter(year == input$year4)
  })  
  
  
  output$error_5 <- renderTable({
    error_5_table %>%
      filter(year == input$year5)
  })
  
  output$error_6 <- renderTable({
    error_6_table %>%
      filter(year == input$year6)
  })
  
  output$query <- renderTable({
    query_1_table %>%
      filter(year == input$yearQ)
  })
  
  output$RCodes <- renderTable({
    RCodes_table %>%
      filter(year == input$yearR)
  })
  
  # output$split_1 <- DT::renderDataTable({
  #   DT::datatable(split_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  # },
  # rownames = FALSE)
  # 
  # output$split_2 <- DT::renderDataTable({
  #   DT::datatable(split_2_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  # },
  # filter = 'top',
  # rownames = FALSE)
  # 
  # output$split_3 <- DT::renderDataTable({
  #   DT::datatable(split_3_table, filter = 'top', options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  # },
  # rownames = FALSE)
  # 
  # output$split_4 <- DT::renderDataTable({
  #   DT::datatable(split_4_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  # },
  # filter = 'top',
  # rownames = FALSE)
  # 
  # output$split_5 <- DT::renderDataTable({
  #   DT::datatable(split_5_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  # },
  # filter = 'top',
  # rownames = FALSE)
  # 
  # output$error1map <- renderLeaflet({ #create maps
  #   error1map
  # })
  # 
  # output$error2map <- renderLeaflet({
  #   error2map
  # })
  # 
  # output$error3map <- renderLeaflet({
  #   error3map
  # })
  # 
  # output$error4map <- renderLeaflet({
  #   error4map
  # })
  # 
  # output$error5map <- renderLeaflet({
  #   error5map
  # })
  # 
  # output$error6map <- renderLeaflet({
  #   error6map
  # })
  # 
  # output$querymap <- renderLeaflet({
  #   query_map
  # })
  
  
})
