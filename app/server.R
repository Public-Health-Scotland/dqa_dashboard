shinyServer(function(input, output, session) {

### SMR Completeness
  ##setting the selection filter settings for the table
  
  # Health Board filter
  hb_completeness <- reactive({
    if(input$hb_in %in% unique(smr_completeness$hb_name)){
      smr_completeness %>%
        filter(hb_name==input$hb_in)
    }
    else{
      smr_completeness
    }
  })
  
  #Month filter
  month_completeness <- reactive({
    if(input$month_in %in% unique(hb_completeness()$month_record_inserted)){
      hb_completeness() %>%
        filter(month_record_inserted==input$month_in)
    }
    else{
      hb_completeness()
    }
  })
 
  #Mandatory data items filter 
  mandatory_completeness <- reactive({ 
    month_completeness() %>%
    filter(case_when(input$mandatory_in == "Mandatory data items" ~ mandatory == "mandatory",
                     input$mandatory_in == "Non-mandatory data items" ~ mandatory == "not mandatory",
                     TRUE ~ mandatory == mandatory))
  })
  
  #Depending on the user's selection in the Mandatory filter, the list of possible data items is 
  # updated with updateSelectInput()
  
    observeEvent(input$mandatory_in, {
    updateSelectInput(session, inputId = "data_item_in",
                      choices = c("(All)", unique(mandatory_completeness()$data_item)))
  })
  
    #Data Item filter
  data_item_completeness <- reactive({
    if(input$data_item_in %in% unique(mandatory_completeness()$data_item)){
      mandatory_completeness()%>%
        filter(data_item==input$data_item_in)
    }
    else{
      mandatory_completeness()
    }
  })

  #Percentage complete filter
    #The user selects a threshold percentage using the slider, 
    #and the table filters all the rows with a percentage above the threshold
  data_item_percent <- reactive({
    mandatory_completeness()%>%
      filter(percent_complete_month >= input$percentage_in)%>%
      arrange(percent_complete_month)
  })
  
  output$completeness_table <- renderTable(data_item_percent()%>%
                                             select(-na_count, -month_total, -mandatory))
  

  
### SMR Audit
  #If user selects an audit, filter the data for selected audit, if they select (All) return unfiltered table 
  audit <- reactive({
    if(input$SMRaudit %in% smr_audit$audit){
      smr_audit %>%
        filter(audit==input$SMRaudit)
    }
    else {
      smr_audit
    }
  })
  
  #observe the audit selected by user and update the choices according to the audit selection
  observeEvent(input$SMRaudit, {
    updateSelectInput(session, inputId = "Year", choices = c(unique(audit()$year)))
  })
  
  
  #reactive year selection, returns data filtered by the year selected 
  year <- reactive({audit()%>%
      filter(year == input$Year)})
  
  # year <- reactive({
  #   if(input$Year %in% audit()$Year){
  #     audit() %>%
  #       filter(Year == input$Year)
  #   }
  #   else {
  #     audit()
  #   }
  # })
  
  
  #observe the year selected and update the health board choices, the (All) option is added so that users can view all HBs by default
  observeEvent(input$Year, {
    updateSelectInput(session, inputId = "Healthboard", choices = c("(All)", unique(year()$healthboard)))
  })
  
  #reactive health board selection, if a specific HB is selected filter the data further, else return the table reaturned by the reactive year()
  healthboard <- reactive({
    if(input$Healthboard %in% year()$healthboard){
      year()%>%
        filter(healthboard == input$Healthboard)
    }
    else {
      year()
    }
  })
  
  
  #update the data item choices according to the SMR selected
  observeEvent(input$SMRaudit, {
    updateSelectInput(session,"DataItemName", choices = c("(All)",unique(audit()$data_item_name)))
  })  
  
  
  #final output applies a data item filter if user picks a specific data item, else it returns table generated by the reactive healthboard()  
  output$audit_data <- renderTable({
    if(input$DataItemName %in% healthboard()$data_item_name){
      healthboard()%>%
        filter(data_item_name == input$DataItemName) %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Mean Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
    else {
      healthboard() %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
  })
  

  
###the following lines relate to SMR02 coding discrepancies
  output$error_1 <- DT::renderDataTable({
    DT::datatable(error_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15)) #default the displayed rows
  },
  filter = 'top',
  rownames = FALSE)    
  
  output$error_2 <- DT::renderDataTable({
    DT::datatable(error_2_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE) 
  
  
  output$error_3 <- DT::renderDataTable({
    DT::datatable(error_3_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  
  output$error_4 <- DT::renderDataTable({
    DT::datatable(error_4_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)  
  
  
  output$error_5 <- DT::renderDataTable({
    DT::datatable(error_5_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$error_6 <- DT::renderDataTable({
    DT::datatable(error_6_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$query <- DT::renderDataTable({
    DT::datatable(query_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_1 <- DT::renderDataTable({
    DT::datatable(split_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_2 <- DT::renderDataTable({
    DT::datatable(split_2_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_3 <- DT::renderDataTable({
    DT::datatable(split_3_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_4 <- DT::renderDataTable({
    DT::datatable(split_4_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_5 <- DT::renderDataTable({
    DT::datatable(split_5_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$error1map <- renderLeaflet({ #create maps
    error1map
  })
  
  output$error2map <- renderLeaflet({
    error2map
  })
  
  output$error3map <- renderLeaflet({
    error3map
  })
  
  output$error4map <- renderLeaflet({
    error4map
  })
  
  output$error5map <- renderLeaflet({
    error5map
  })
  
  output$error6map <- renderLeaflet({
    error6map
  })
  
  output$querymap <- renderLeaflet({
    query_map
  })
  
  
})
