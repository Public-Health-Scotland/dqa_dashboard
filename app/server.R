shinyServer(function(input, output, session) {
  
  #If user selects an audit, filter the data for selected audit, if they select (All) return unfiltered table 
  audit <- reactive({
    if(input$SMRaudit %in% smr_audit$audit){
      smr_audit %>%
        filter(audit==input$SMRaudit)
    }
    else {
      smr_audit
    }
  })
  
  #observe the audit selected by user and update the choices according to the audit selection
  observeEvent(input$SMRaudit, {
    updateSelectInput(session, inputId = "Year", choices = c(unique(audit()$year)))
  })
  
  
  #reactive year selection, returns data filtered by the year selected 
  year <- reactive({audit()%>%
      filter(year == input$Year)})
  
  # year <- reactive({
  #   if(input$Year %in% audit()$Year){
  #     audit() %>%
  #       filter(Year == input$Year)
  #   }
  #   else {
  #     audit()
  #   }
  # })
  
  
  
  
  #observe the year selected and update the health board choices, the (All) option is added so that users can view all HBs by default
  observeEvent(input$Year, {
    updateSelectInput(session, inputId = "Healthboard", choices = c("(All)", unique(year()$healthboard)))
  })
  
  #reactive health board selection, if a specific HB is selected filter the data further, else return the table reaturned by the reactive year()
  healthboard <- reactive({
    if(input$Healthboard %in% year()$healthboard){
      year()%>%
        filter(healthboard == input$Healthboard)
    }
    else {
      year()
    }
  })
  
  
  
  #update the data item choices according to the SMR selected
  observeEvent(input$SMRaudit, {
    updateSelectInput(session,"DataItemName", choices = c("(All)",unique(audit()$data_item_name)))
  })  
  
  
  #final output applies a data item filter if user picks a specific data item, else it returns table generated by the reactive healthboard()  
  output$data <- renderTable({
    if(input$DataItemName %in% healthboard()$data_item_name){
      healthboard()%>%
        filter(data_item_name == input$DataItemName) %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Mean Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
    else {
      healthboard() %>%
        select(audit, year, healthboard, hospital, data_item_name, accuracy_scotland, accuracy_hospital)%>%
        rename("SMR" = "audit", "Health Board" = "healthboard", "Data Item" = "data_item_name", "Accuracy Scotland" = "accuracy_scotland",
               "Accuracy Hospital" = "accuracy_hospital")
    }
  })
  
  
  
  #the following lines relate to SMR02 coding discrepancies
  output$error_1 <- DT::renderDataTable({
    DT::datatable(error_1_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15)) #default the displayed rows
  },
  filter = 'top',
  rownames = FALSE)    
  
  output$error_2 <- DT::renderDataTable({
    DT::datatable(error_2_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE) 
  
  
  output$error_3 <- DT::renderDataTable({
    DT::datatable(error_3_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  
  output$error_4 <- DT::renderDataTable({
    DT::datatable(error_4_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)  
  
  
  output$error_5 <- DT::renderDataTable({
    DT::datatable(error_5_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$error_6 <- DT::renderDataTable({
    DT::datatable(error_6_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$split_3 <- DT::renderDataTable({
    DT::datatable(split_3_table, options = list(lengthMenu = c(15, 30, 50), pageLength = 15))
  },
  filter = 'top',
  rownames = FALSE)
  
  output$error1map <- renderLeaflet({ #create maps
    error1map
  })
  
  output$error2map <- renderLeaflet({
    error2map
  })
  
  output$error3map <- renderLeaflet({
    error3map
  })
  
  output$error4map <- renderLeaflet({
    error4map
  })
  
  output$error5map <- renderLeaflet({
    error5map
  })
  
  output$error6map <- renderLeaflet({
    error6map
  })
  
  
  
})
